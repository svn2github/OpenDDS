eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
    & eval 'exec perl -S $0 $argv:q'
    if 0;

# $Id$
# -*- perl -*-

# Locate the project - *before* we use it to locate Perl modules
use FindBin;
my $projectRoot;
BEGIN { $projectRoot = "$FindBin::Bin/.."; }

# Use information from the environment.
use Env qw( @LD_LIBRARY_PATH
            @LIB_PATH
            @SHLIB_PATH
            @PATH
            $DDS_ROOT
            $ACE_ROOT);

# Locate the Perl modules
use lib "$ACE_ROOT/bin";
use lib "$DDS_ROOT/bin";
use lib "$projectRoot/bin";
use PerlDDS::Run_Test;

########################################
#
# Locate the link libraries
# PerlDDS::add_lib_path( "$projectRoot/lib");
#  NOTE: add_lib_path() does not appear to export the path to the
#        subprocess sufficiently for use by our subprocesses.
unshift @LD_LIBRARY_PATH, "$projectRoot/lib";
unshift @LIB_PATH,        "$projectRoot/lib";
unshift @SHLIB_PATH,      "$projectRoot/lib";

# I find this a particularly heinous setting.
if( $^O eq 'MSWin32') { unshift @PATH, "$projectRoot/lib"; }
#
########################################

use Getopt::Long qw( :config bundling) ;
use Pod::Usage ;

my $status = 0;
my $failed = 0;

#
# Basic options.
#
my $debug;
my $man;
my $help;
my $verbose;
my $orbVerbose;
my $dFile;
my $rawData;
my $rawSize = 4 * 1024;
my $transportDebug;
my $repoDebug;
my $noaction;

#
# Specific options.
#
my $duration;
my $startRepo;
my $startTest;
my $repoHost;
my $iniFile  = $projectRoot . "/etc/transport.ini";
my $scenarios;
my $collectStats;

########################################################################
#
# Process the command line.
#
#   -v -V -? -d -T -R -x -f -C -r -h -s -i -S -P -t
#
GetOptions( "verbose!"            => \$verbose,
            "v"                   => \$verbose,
            "ORBVerboseLogging|V" => \$orbVerbose,
            "help|?"              => \$help,
            "man"                 => \$man,
            "debug|d=i"           => \$debug,
            "tdebug|T=i"          => \$transportDebug,
            "rdebug|R=i"          => \$repoDebug,
            "noaction|x"          => \$noaction,
            "dfile|f=s"           => \$dFile,
            "collect|C=s"         => \$collectStats,
            "rawdatafile|r=s"     => \$rawData,
            "repohost|h=s"        => \$repoHost,
            "inifile|i=s"         => \$iniFile,
            "scenario|s=s"        => \$scenarios,
            "startrepo|S"         => \$startRepo,
            "starttest|P"         => \$startTest,
            "duration|t=i"        => \$duration,

) or pod2usage( 0) ;
pod2usage( 1)             if $help or ($startTest and not $scenarios);
pod2usage( -verbose => 2) if $man;
#
########################################################################

# Extract the individual scenarios.
my @scenario = split( ',', $scenarios);

# Allow 'all' to be specified for statistics collection.
$collectStats = "psn" if $collectStats =~ /al?l?/;

# Verbosity.
print "Commands will be printed only and not executed.\n"
                                          if $verbose and $noaction;
print "Repository will be started\n"      if $verbose and $startRepo;
print "Test process will be started\n"    if $verbose and $startTest;
print "Test will execute for at least $duration seconds before terminating\n"
                                          if $verbose and $duration;
print "Test will execute continuously and not terminate\n"
                                          if $verbose and not $duration;
print "ProjectRoot==$projectRoot\n"       if $verbose;
print "RepoHost==$repoHost\n"             if $verbose;
print scalar(@scenario) . " scenarios==" . join(', ', @scenario) . "\n"
                                          if $verbose;
print "RawDataFile==$rawData\n"           if $verbose and $rawData;
print "Process Statistics will be collected.\n"
                                          if $verbose and $collectStats =~ /p/;
print "System Statistics will be collected.\n"
                                          if $verbose and $collectStats =~ /s/;
print "Network Statistics will be collected.\n"
                                          if $verbose and $collectStats =~ /n/;

print "Debug==$debug\n"                   if $verbose and $debug;
print "RepoDebug==$repoDebug\n"           if $verbose and $repoDebug;
print "TransportDebug==$transportDebug\n" if $verbose and $transportDebug;
print "DebugFile==$dFile\n"               if $verbose and $dFile;
print "VerboseLogging==$orbVerbose\n"     if $verbose and $orbVerbose;

# Kill processes after specified duration plus a one minute grace period
# if they do not terminate independently.
my $killDelay = 60;
$killDelay += $duration if $duration;

# Files.
my $repo_ior  = PerlACE::LocalFile("repo.ior");
my $debugFile;
   $debugFile = PerlACE::LocalFile( $dFile) if $dFile;
my $confFile  = $projectRoot . "/etc/svc.conf";

# Clean out leftovers.
unlink $repo_ior;
unlink $debugFile if $debugFile;

my $verboseDebug;
$verboseDebug = "-ORBVerboseLogging 1 " if $orbVerbose;

my $common_opts = new PerlACE::ConfigList->check_config ('STATIC') ? ''
    : "-ORBSvcConf $confFile ";
$common_opts .= $verboseDebug if $verboseDebug;
$common_opts .= "-DCPSTransportDebugLevel $transportDebug " if $transportDebug;

# Establish process arguments.

my $appDebug;
$appDebug  = $debug if $debug;

my $repoOpts = "$common_opts ";
$repoOpts .= "-ORBListenEndpoints $repoHost " if $repoHost;
$repoOpts .= "-DCPSDebugLevel $repoDebug " if $repoDebug;
$repoOpts .= "-ORBLogFile $debugFile " if ($repoDebug or $transportDebug) and $debugFile;

my $index = 0;
my $testOpts = "$common_opts ";
$testOpts .= "-v " if $verbose;
$testOpts .= "-DCPSConfigFile $iniFile " if $iniFile;
$testOpts .= "-DCPSDebugLevel $appDebug " if $appDebug;
$testOpts .= "-ORBLogFile $debugFile " if ($appDebug or $transportDebug) and $debugFile;
$testOpts .= "-DCPSInfoRepo corbaloc:iiop:$repoHost/DCPSInfoRepo ";
$testOpts .= "-d $duration " if $duration;
$testOpts .= "-t newest -s $rawSize -r $rawData " if $rawData;


# Define the processes.
my @PROCESSES;

if( $startRepo) {
  my $repoArgs = "$repoOpts -o $repo_ior ";
  if( PerlACE::is_vxworks_test()) {
    push @PROCESSES, new PerlACE::ProcessVX( "$FindBin::Bin/DCPSInfoRepo", $repoArgs);
  } else {
    push @PROCESSES, new PerlACE::Process( "$FindBin::Bin/DCPSInfoRepo", $repoArgs);
  }
}

if( $startTest) {
  map {
    my $testArgs = "$testOpts -f $_ ";
    if( PerlACE::is_vxworks_test()) {
      push @PROCESSES, new PerlACE::ProcessVX( "$FindBin::Bin/testprocess", $testArgs);
    } else {
      push @PROCESSES, new PerlACE::Process( "$FindBin::Bin/testprocess", $testArgs);
    }
  } @scenario;
}

if( $noaction) {
  # Be verbose.
  map { print $_->CommandLine() . "\n"; } @PROCESSES;
  exit;
}

# Manage statistics collection processes.
my @COLLECTORS;
my @HANDLES;
&collectSystemStats( $$)  if $collectStats =~ /s/;

# Start and stop the test processes.
map {
  print "\nTEST PROCESS\n";
  print $_->CommandLine() . "\n";
  $_->Spawn();
  &collectProcessStats( $_->{PROCESS}) if $collectStats =~ /p/;
  &collectNetworkStats( $_->{PROCESS}) if $collectStats =~ /n/;
  if( $startRepo and PerlACE::waitforfile_timed( $repo_ior, 30) == -1) {
    print STDERR "ERROR: waiting for repository IOR file $repo_ior.\n";
    exit 1;
  }
} @PROCESSES;

# block forever if no duration was specified.
WaitForUserInput() if not $duration;

# Wait for the test processes to terminate nicely.  Terminate in reverse
# order from starting order.
map {
  if ($duration) {
    $status = $_->WaitKill( $killDelay);
  } else {
    $status = $_->TerminateWaitKill( $killDelay);
  }
  print "Terminated test process.\n" if $verbose;
  if( $status != 0) {
    print STDERR "ERROR: Test returned $status\n";
    ++$failed;
  }
  $killDelay = 5;
} reverse @PROCESSES;

# Clean up after the repository.
if( $startRepo) {
  unlink $repo_ior;
}

# Terminate the statistics collectors.
kill 3, @COLLECTORS;

# Report results.
if( $failed == 0) {
  print "test PASSED.\n";

} else {
  print STDERR "test FAILED.\n";
}

exit $failed;

sub WaitForUserInput {
  print "\n\nNo Duration specified.  Hit Enter to end the processes "
      . "and finish the test.\n\n";
  my $userinput = <STDIN>;
}

#
# Statistics gathering commands by system type
#
# The collection processing will start the command /once/, then capture
# the output and process it line by line.  As this script is terminating,
# it will send an INT (3) signal to the process to stop it.
#
# If a system type does not honor the commands as written, add a stanza
# for that system type and modify the commands to be appropriate for that
# environment.
#
sub collectionCommand {
  my ( $type, $params) = @_;
  SWITCH:{
    $^O =~ /MSWin32/ && do {
      return undef;
    };
    $^O =~ /cygwin/ && do {
      return undef;
    };
    $^O =~ /VMS/ && do {
      return undef;
    };
    $^O =~ /solaris/ && do {
      return "vmstat 1"  if $type eq "system";
      return undef       if $type eq "network";
      return "top -bd 1" if $type eq "process"; # This still may not work.
    };

    # Handle generic Unix types here.  Assume they have modern command
    # forms.  If not, add a stanza to handle them specifically above.
    return "vmstat 1"             if $type eq "system";
    return "netstat -ntpc"        if $type eq "network";
    return "top -bd 1 -p $params" if $type eq "process";
  }
  return undef;
}

sub collectProcessStats {
  my $pid = shift;
  my $command = &collectionCommand( 'process', "$pid");
  if( $pid and $command) {
    &runCollector(
      $command,
      "process-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n" if $input =~ /$pid/;
      }
    );
  }
}

sub collectSystemStats {
  my $pid = shift;
  my $command = &collectionCommand( 'system');
  if( $pid and $command) {
    &runCollector(
      $command,
      "system-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n";
      }
    );
  }
}

sub collectNetworkStats {
  my $pid = shift;
  my $command = &collectionCommand( 'network');
  if( $pid and $command) {
    &runCollector(
      $command,
      "network-$pid.log",
      sub { # Action to process each line of input.
        my ( $input, $output) = @_;
        print $output localtime() . ": $input\n" if $input =~ /$pid/;
      }
    );
  }
}

sub runCollector {
  my ( $command, $filename, $action) = @_;

  # Start a sub-process to collect statistics.
  my $child = open( my $handle, "-|");
  if( not defined($child)) { # Broken
    warn "Unable to start statistics collection: $!";

  } elsif( $child) { # Parent
    # Obtain the statistics process Id to terminate processing with.
    my $cmd = <$handle>;
    chomp $cmd;
    push @COLLECTORS, $cmd; # For terminating.
    push @HANDLES, $handle; # For process scope.
    print "Starting to write statistics to <$filename> "
        . "from process <$cmd> running <$command>.\n";

  } else { # Child
    # Prevent issues with test process management in the child.  The
    # managed processes are managed only by the parent process.
    map $_->{RUNNING} = 0, @PROCESSES;

    # Start collecting using the provided command as input.
    my $cmd = open( STATSIN, "$command |")
      or die "Failed to start statistics gathering command <$command>: $!";

    # Send the command PID to the parent process.
    print "$cmd\n";

    # Open and unbuffer the output.
    open( my $output, "> $filename")
      or die "Failed to open statistics output file <$filename>: $!";
    select $output; $!=1;

    # Process all of the input.
    while(<STATSIN>) {
      s/\s+$//; # Elide trailing whitespace; 'chomp' doesn't work quite right.
      $action->( "$_", $output);
    }

    # Done collecting.
    close $output;
    exit;
  }
}

=head1 NAME

run_test - Execute test processes for distributed testing

=head1 SYNOPSIS

 run_test [options]

Options:

  -? | --help            brief help message

  --man                  full documentation

  -x | --noaction        do not execute any processing

  -v | --verbose         be chatty while executing

  -V NUMBER | --ORBVerboseLogging=NUMBER
                         set the corresponding ORB option

  -d NUMBER | --debug=NUMBER
                         set the DCPS debugging level

  -T NUMBER | --tdebug=NUMBER
                         set the DCPSTransportDebug debugging level

  -R NUMBER | --rdebug=NUMBER
                         set the DCPS debugging level for the repository

  -f FILE | --dfile=FILE set the filename for debug output

  -C TYPES | --collect=TYPES
                         collect process and system statistics during test

  -h FQDN | --repohost FQDN
                         fully qualified domain name (and port) for
                         connecting to repository

  -i FILE | --inifile FILE
                         file for configuring the OpenDDS service

  -s FILELIST | --scenario FILELIST
                         list of files defining the test scenario(s) to execute

  -r FILE | --rawdatafile FILE
                         file to write collected data to at end of test

  -t NUMBER | --duration=NUMBER
                         limit the duration of test execution

  -S | --startrepo       start a repository

  -P | --starttest       start a testprocess

=head1 OPTIONS

=over 8

=item B<-?> | B<--help>

Print a brief help message and exits.

=item B<--man>

Prints this manual page and exits.

=item B<-x> | B<--noaction>

Print the commands that would be executed with the current set of command
line options and exit without starting any processes.

=item B<-v> | B<--verbose>

Print additional information while executing.

=item B<-V> | B<--ORBVerboseLogging=NUMBER>

Sets the -ORBVerboseLogging option to NUMBER.

The default value is 0.

The value is set to 1 if any non-zero value is specified.  A value of
zero will omit the ORBVerboseLogging specification from the process
command line.

=item B<-d NUMBER> | B<--debug=NUMBER>

Sets the -DCPSDebugLevel option value.  A value of 0 will omit the
DCPSDebugLevel specification from the process command line.

The default value is 0.

=item B<-T NUMBER> | B<--tdebug=NUMBER>

Sets the -DCPSTransportDebugLevel option value.  A value of 0 will omit
the DCPSTransportDebugLevel specification from the process command line.

The default value is 0.

=item B<-R NUMBER> | B<--rdebug=NUMBER>

Sets the -DCPSDebugLevel option value for the repository process.  A
value of 0 will omit the DCPSDebugLevel specification from the repository
process command line.

The default value is 0.

=item B<-t NUMBER> | B<--duration=NUMBER>

Limits the execution time of the test.  If not specified, then any test
or repository process that is started will execute until the script is
interrupted.

The default value is unspecified.

=item B<-S> | B<--startrepo>

Causes a repository process to be started.  Only a single repository
process will be invoked by an invocation.

The default value is to not start a repository process.

=item B<-P> | B<--starttest>

Causes one or more test processes to be started.  One process will be
started for each test file specified by the B<-s> option.

The default value is to not start a test process.

=item B<-f FILE> | B<--dfile=FILE>

Sets the -ORBLogFile option value.  A value of unspecified will result in
the ORBLogFile specification being omitted from the process command line.

The default value is unspecified.

=item B<-C TYPES> | B<--collect=TYPES>

Starts statistics collection for the specified TYPES.  TYPES may contain
one or more of the values: C<n>, C<s>, and C<p>, or the collective
specification C<all>.

=over 8

=item B<n>

Causes network statistics to be gathered.  A C<netstat -ntpc> command is
started for each test process and the output filtered by its process Id.
The output is stored to a file named I<network-{pid}.log>.

=item B<s>

Causes system statistics to be gathered.  A single C<vmstat 1> command is
started and the output stored in a file named I<system-{pid}.log>, where
the pid value is for the test script.

=item B<p>

Causes process statistics to be gathered.  A C<top -bd 1 -p {pid}>
command is started for each test process and the output filtered by its
process Id.  The output is stored to a file named I<process-{pid}.log>.

=back

The default is unspecified.  This results in no statistics being
collected.

=item B<-h FQDN> | B<--repohost=FQDN>

This is the fully qualified domain name and port where the OpenDDS
repository may be found.

The default value is 'localhost:2112'.

=item B<-i FILE> | B<--inifile=FILE>

OpenDDS configuration filename.  This defines the configuration
information for the OpenDDS service.

The default is to use the file located in the 'etc' directory relative
from the project root (the parent directory of the directory where the
command was executed from) with filename 'transport.ini'.

=item B<-s FILELIST> | B<--scenario=FILELIST>

Test scenario definition filenames.  This defines the scenarios to execute
for the test.  This names an 'ini' style file that contains information
about all publications and subscriptions to execute for this test
execution.  This can be one or more filenames, separated by commas.  One
test process will be started (if requested) to process each named
scenario configuration file.

The default is not specified.  This will result in no test processes
being started if the B<-P> argument is given.

=item B<-r FILE> | B<--rawdatafile=FILE>

Raw data output filename.  This file is where any raw latency data
collected during the test will be written.

The default is unspecified.

I<This is deprecated in favor of the test configuration specification for
this filename.>

=back

=head1 DESCRIPTION

This script manages execution of the processes needed for distributed
testing of OpenDDS using the OpenDDS-Bench performance testing framework.
The processes used by the framework include the OpenDDS specific
repository process and the test specific process.  The repository
executable is the standard OpenDDS C<DCPSInfoRepo> program.  The framework
C<testprocess> program is specific to this testing and provides the
ability to start multiple publications and / or subscriptions within a
single process.

It is possible to start any number of C<testprocess> programs at once.
A separate process will be started for each configuration file supplied.
The same configuration file can be included more than once to start
separate processes with the same configuration.

Processes started by this script will either execute until terminated by
the user (no duration specified) or until a specified duration has
elapsed.  For the C<testprocess> commands, the duration is passed to the
program to allow it to terminate cleanly.  The script will wait 60
seconds beyond this time and then terminate the process by force.

This script will establish the environment for the executable processes
by adding the test library to the runtime library search path.

=head1 EXAMPLES

=over 8

=item B<bin/run_test -vx -P -s s1.ini>

prints the commands that would be invoked when starting a single test
process with the s1.ini test specification.  This will also be verbose
during setup processing.

=item B<bin/run_test -d 10 -C n -T 4 -P -s test.ini -f test.log -h localhost:2038>

starts a test process using the C<test.ini> specification file and expecting
to find the repository process at localhost:2038.  It will run with
C<DCPSDebugLevel> of 10, C<DCPSTransportDebugLevel> of 4 and put the logging
output to the C<test.log> file.  Network statistics will be gathered for
connections to the test process.

=item B<bin/run_test -x -t 120 -s scenario1.ini,scenario1.ini,other.ini>

prints the commands that would be invoked when starting 3 test processes:
two using the scenario1.ini specification file and one using the other.ini
specification file.  The test would be scheduled to last for 2 minutes.

=item B<bin/run_test -vd10T4VCall -s test.ini -h machine.domain.com:2112>

starts a test process using the C<test.ini> specification file and
expecting to connect to the repository at C<machine.domain.com:2112>.  It
will run with C<DCPSDebugLevel> of 10, C<DCPSTransportDebugLevel> of 4,
C<ORBVerboseLogging> enabled and both the script and test process will
execute in verbose mode.  The log output will be directed to the standard
output.  All statistics - system, network, and process - will be gathered.

=back

=cut

__END__

# vim: filetype=perl

