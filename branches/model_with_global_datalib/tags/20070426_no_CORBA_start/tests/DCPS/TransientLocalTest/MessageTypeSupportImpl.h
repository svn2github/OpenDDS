// -*- C++ -*-
//
// $Id$

// Generated by dcps_ts.pl

#ifndef MESSAGETYPESUPPORTI_H_
#define MESSAGETYPESUPPORTI_H_

#include "MessageTypeSupportS.h"
#include "dds/DCPS/DataWriterImpl.h"
#include "dds/DCPS/DataReaderImpl.h"
#include "dds/DCPS/Dynamic_Cached_Allocator_With_Overflow_T.h"
#include "dds/DCPS/DataBlockLockPool.h"
#include "dds/DCPS/ZeroCopySeq_T.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
#pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


  // for support of zero-copy read
  typedef ::TAO::DCPS::ZeroCopyDataSeq<Messenger::Message, DCPS_ZERO_COPY_SEQ_DEFAULT_SIZE> MessageZCSeq;



/** Servant for TypeSuport interface of Message data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 */
class  MessageTypeSupportImpl
  : public virtual POA_MessageTypeSupport,
    public virtual PortableServer::RefCountServantBase
{
public:
  //Constructor
  MessageTypeSupportImpl (void);

  //Destructor
  virtual ~MessageTypeSupportImpl (void);

  virtual
  DDS::ReturnCode_t register_type (
      ::DDS::DomainParticipant_ptr participant,
      const char * type_name
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  char * get_type_name (
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  ::TAO::DCPS::DataWriterRemote_ptr create_datawriter (
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  ::TAO::DCPS::DataReaderRemote_ptr create_datareader (
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  private:
    CORBA::String_var type_name_;
};




/** Servant for DataWriter interface of the Message data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 */
class  MessageDataWriterImpl
  : public virtual POA_MessageDataWriter,
    public virtual TAO::DCPS::DataWriterImpl,
    public virtual PortableServer::RefCountServantBase
{
public:
  typedef std::map<Messenger::Message, DDS::InstanceHandle_t,
      MessageKeyLessThan> InstanceMap;
  typedef ::TAO::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Null_Mutex>  DataAllocator;

  //Constructor
  MessageDataWriterImpl (void);

  //Destructor
  virtual ~MessageDataWriterImpl (void);

  virtual
  DDS::InstanceHandle_t _cxx_register (
      const ::Messenger::Message & instance_data
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::InstanceHandle_t register_w_timestamp (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t unregister (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t handle
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t unregister_w_timestamp (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual
  DDS::ReturnCode_t write (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t handle
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  //WARNING: If the handle is non-nil and the instance is not registered
  //         then this operation may cause an access violation.
  //         This lack of safety helps performance.
  virtual
  DDS::ReturnCode_t write_w_timestamp (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t handle,
      const ::DDS::Time_t & source_timestamp
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t dispose (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t instance_handle
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t dispose_w_timestamp (
      const ::Messenger::Message & instance_data,
      ::DDS::InstanceHandle_t instance_handle,
      const ::DDS::Time_t & source_timestamp
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t get_key_value (
      ::Messenger::Message & key_holder,
      ::DDS::InstanceHandle_t handle
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));


  /**
   * Initialize the DataWriter object.
   * Called as part of create_datawriter.
   */
  virtual void init (
        ::DDS::Topic_ptr                       topic,
        TAO::DCPS::TopicImpl                 *topic_servant,
        const ::DDS::DataWriterQos &           qos,
        ::DDS::DataWriterListener_ptr          a_listener,
        TAO::DCPS::DomainParticipantImpl*      participant_servant,
        ::DDS::Publisher_ptr                   publisher,
        TAO::DCPS::PublisherImpl*              publisher_servant,
        TAO::DCPS::DataWriterRemote_ptr        dw_remote
      )
        ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataWriterImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific (
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

  /**
   * The framework has completed its part of unregistering the
   * given instance.
   */
  virtual void unregistered(::DDS::InstanceHandle_t   instance_handle);

  /**
   * Accessor to the marshalled data sample allocator.
   */
  ACE_INLINE
  DataAllocator* data_allocator () const  {
    return data_allocator_;
  }

private:

  /**
   * Serialize the instance data.
   *
   * @param instance_data The data to serialize.
   * @param for_write If 1 use the fast allocator; otherwise use the heap.
   * @return returns the serialized data.
   */
  ACE_Message_Block* marshal(
    const ::Messenger::Message& instance_data,
    int  for_write = 1);

  /**
   * Find the instance handle for the given instance_data using
   * the data type's key(s).  If the instance does not already exist
   * create a new instance handle for it.
   */
  ::DDS::ReturnCode_t get_or_create_instance_handle(
    DDS::InstanceHandle_t& handle,
    const ::Messenger::Message& instance_data,
    const ::DDS::Time_t & source_timestamp);

  /**
   * Get the InstanceHanle for the given data.
   */
  ::DDS::InstanceHandle_t get_instance_handle(
    ::Messenger::Message instance_data);

   InstanceMap  instance_map_;
   size_t       marshaled_size_;
   // The lock pool will be thread safe because
   // only one write call is allowed at a time.
   DataBlockLockPool*  db_lock_pool_;
   DataAllocator* data_allocator_;
   ::TAO::DCPS::MessageBlockAllocator* mb_allocator_;
   ::TAO::DCPS::DataBlockAllocator*    db_allocator_;
};



/** Servant for DateReader interface of Message data type.
 *
 * See the DDS specification, OMG formal/04-12-02, for a description of
 * this interface.
 *
 * @note zero-copy methods are specific to TAO but this is allowed by
 *       the DDS specification.
 *
 */
class  MessageDataReaderImpl
  : public virtual POA_MessageDataReader,
    public virtual TAO::DCPS::DataReaderImpl,
    public virtual PortableServer::RefCountServantBase
{
public:
  typedef std::map<Messenger::Message, DDS::InstanceHandle_t,
      MessageKeyLessThan> InstanceMap;
  typedef ::TAO::DCPS::Cached_Allocator_With_Overflow<Messenger::Message, ACE_Null_Mutex>  DataAllocator;

  //Constructor
  MessageDataReaderImpl (void);

  //Destructor
  virtual ~MessageDataReaderImpl (void);

  virtual
  DDS::ReturnCode_t delete_contained_entities (
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  /**
   * Initialize the DataReader object.
   * Called as part of create_datareader.
   */
  virtual
  void init (
        TAO::DCPS::TopicImpl*                    a_topic,
        const ::DDS::DataReaderQos &             qos,
        ::DDS::DataReaderListener_ptr            a_listener,
        TAO::DCPS::DomainParticipantImpl*        participant,
        TAO::DCPS::SubscriberImpl*               subscriber,
        ::DDS::Subscriber_ptr                    subscriber_objref,
        TAO::DCPS::DataReaderRemote_ptr          dr_remote_objref
      )
        ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

  /**
   * Do parts of enable specific to the datatype.
   * Called by DataReaderImpl::enable().
   */
  virtual ::DDS::ReturnCode_t enable_specific (
      )
      ACE_THROW_SPEC ((
        CORBA::SystemException
      ));

  virtual
  DDS::ReturnCode_t read (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  // zero-copy overloaded version
  virtual
  DDS::ReturnCode_t read (
      ::MessageZCSeq & received_data,
      ::TAO::DCPS::SampleInfoZCSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t take (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t take (
      ::MessageZCSeq & received_data,
      ::TAO::DCPS::SampleInfoZCSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t read_next_sample (
      ::Messenger::Message & received_data,
      ::DDS::SampleInfo & sample_info
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t take_next_sample (
      ::Messenger::Message & received_data,
      ::DDS::SampleInfo & sample_info
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t read_instance (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t take_instance (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t read_next_instance (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t take_next_instance (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq,
      ::CORBA::Long max_samples,
      ::DDS::InstanceHandle_t a_handle,
      ::DDS::SampleStateMask sample_states,
      ::DDS::ViewStateMask view_states,
      ::DDS::InstanceStateMask instance_states
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t return_loan (
      ::MessageSeq & received_data,
      ::DDS::SampleInfoSeq & info_seq
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t return_loan (
      ::MessageZCSeq & received_data,
      ::TAO::DCPS::SampleInfoZCSeq & info_seq
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

  virtual
  DDS::ReturnCode_t get_key_value (
      ::Messenger::Message & key_holder,
      ::DDS::InstanceHandle_t handle
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));

 virtual 
 DDS::ReturnCode_t auto_return_loan(void* seq);

 void
 MessageDataReaderImpl::release_loan (
           ::MessageZCSeq & received_data
           );

 protected:

    virtual void demarshal(const TAO::DCPS::ReceivedDataSample& sample) ;

    virtual void dispose(const TAO::DCPS::ReceivedDataSample& sample) ;

    //virtual TAO::DCPS::DataReaderRemote_ptr get_datareaderremote_obj_ref ();

  private:
    ::DDS::ReturnCode_t  store_instance_data(
         ::Messenger::Message *instance_data,
         const TAO::DCPS::DataSampleHeader& header
         ) ;

   InstanceMap  instance_map_;
   DataAllocator* data_allocator_;
};



#endif /* MESSAGETYPESUPPORTI_H_  */


