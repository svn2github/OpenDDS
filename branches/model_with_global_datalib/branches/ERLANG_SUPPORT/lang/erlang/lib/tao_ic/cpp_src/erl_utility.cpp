/*
 * $Id$
 */

#include <cstring>
#include <iterator>

#include "global_extern.h"

#include "be_extern.h"
#include "be_global.h"
#include "erl_utility.h"

using namespace std;

const char* erl_identifier::sep = "_";

erl_identifier::erl_identifier(Identifier* name)
  : str_(name->get_string())
{
  init();
}

erl_identifier::erl_identifier(UTL_ScopedName *name)
{
  UTL_IdListActiveIterator it(name);
  while (!it.is_done())
  {
    Identifier* item = it.item();
    it.next();
      
    str_.append(item->get_string());
    if (!it.is_done())
    {
      str_.append(sep);
    }
  }
  init();
}

erl_identifier::~erl_identifier()
{
}

void
erl_identifier::init()
{
  // Strip leading underscores
  for (string::iterator it(str_.begin()); it != str_.end(); ++it)
  {
    if (*it != '_') break;
    it = str_.erase(it);
  }

  // Convert to lower case
  for (string::iterator it(str_.begin()); it != str_.end(); ++it)
  {
    *it = tolower(*it);
  }
}

string
erl_identifier::as_var() const
{
  string s(str_);
  
  s[0] = toupper(s[0]);

  return s;
}

string
erl_identifier::str() const
{
  return str_;
}

erl_identifier::operator string() const
{
  return str_;
}

ostream&
operator<<(ostream& os, const erl_identifier& rhs)
{
  return os << rhs.str_;
}


erl_identifier_list::erl_identifier_list()
{
}

erl_identifier_list::~erl_identifier_list()
{
}

void
erl_identifier_list::add(const erl_identifier& name)
{
  v_.push_back(name);
}

erl_identifier_list::iterator
erl_identifier_list::begin()
{
  return v_.begin();
}

erl_identifier_list::const_iterator
erl_identifier_list::begin() const
{
  return v_.begin();
}

erl_identifier_list::iterator
erl_identifier_list::end()
{
  return v_.end();
}

erl_identifier_list::const_iterator
erl_identifier_list::end() const
{
  return v_.end();
}

size_t
erl_identifier_list::size() const
{
  return v_.size();
}

string
erl_identifier_list::as_param_list() const
{
  ostringstream os;

  const_iterator it(begin());
  while (it != end())
  {
    os << (*it++).as_var();
    if (it != end())
    {
      os << ", ";
    }
  }

  return os.str(); 
}

string
erl_identifier_list::as_init_list() const
{
  ostringstream os;

  const_iterator it(begin());
  while (it != end())
  {
    erl_identifier name = *it++;
   
    os << name << "=" << name.as_var();
    if (it != end())
    {
      os << ", ";
    }
  }

  return os.str(); 
}

ostream&
operator<<(ostream& os, const erl_identifier_list& rhs)
{
  erl_identifier_list::const_iterator it(rhs.begin());
  while (it != rhs.end())
  {
    os << *it++;
    if (it != rhs.end())
    {
      os << ", ";
    }
  }
  return os;
}


erl_literal::erl_literal(AST_Expression* expr)
  : str_(to_str(expr))
{
}

erl_literal::~erl_literal()
{
}

string
erl_literal::str() const
{
  return str_;
}

string
erl_literal::to_str(AST_Expression* expr)
{
  ostringstream os;

  AST_Expression::AST_ExprValue* ev = expr->ev();
  switch (ev->et)
  {
  case AST_Expression::EV_short:
    os << ev->u.sval;
    break;
  case AST_Expression::EV_ushort:
    os << ev->u.usval;
    break;
  case AST_Expression::EV_long:
    os << ev->u.lval;
    break;
  case AST_Expression::EV_ulong:
    os << ev->u.ulval;
    break;
#ifndef ACE_LACKS_LONGLONG_T
  case AST_Expression::EV_longlong:
    os << ev->u.llval;
    break;
  case AST_Expression::EV_ulonglong:
    os << ev->u.ullval;
    break;
#endif /* ACE_LACKS_LONGLONG_T */
  
  case AST_Expression::EV_float:
    os << showpoint << ev->u.fval;
    break;
  case AST_Expression::EV_double:
    os << showpoint << ev->u.dval;
    break;

  case AST_Expression::EV_char:
    os << '$' << ev->u.cval;
    break;
  case AST_Expression::EV_wchar:
    os << '$' << ev->u.wcval;
    break;

  case AST_Expression::EV_octet:
    os << "<<" << unsigned(ev->u.oval) << ">>";
    break;

  case AST_Expression::EV_bool:
    os << boolalpha << ev->u.bval;
    break;

  case AST_Expression::EV_string:
    os << '"' << ev->u.strval->get_string() << '"';
    break;
  case AST_Expression::EV_wstring:
    os << '"' << ev->u.wstrval << '"';
    break;

  default:
    break; // not supported
  }

  return os.str();
}

erl_literal::operator string() const
{
  return str_;
}

ostream&
operator<<(ostream& os, const erl_literal& rhs)
{
  return os << rhs.str_;
}


erl_file::erl_file()
{
}

erl_file::~erl_file()
{
  if (os_.is_open())
  {
    os_.close();
  }
}

ostream&
erl_file::open_stream()
{
  os_.open(filename());
  
  os_ << "%%" << endl
      << "%%" << " $" << "Id" << "$" << endl // avoid keyword expansion
      << "%%" << endl
      << "%% Generated by the tao_ic IDL compiler, version " <<
         TAO_IC_VERSION << endl
      << "%%" << endl
      << "%% Source:" << endl
      << "%%   " << idl_global->filename()->get_string() << endl
      << "%%" << endl
      << "%% AUTOMATICALLY GENERATED FILE - DO NOT EDIT!" << endl
      << "%%" << endl;

  write_header();

  return os_;
}


const char* erl_header::ext = ".hrl";

erl_header::erl_header(UTL_ScopedName* name)
  : name_(name),
    guard_(name_)
{
  // Initialize filename_
  be_global->get_include_dir(filename_);
  filename_.append(basename());
 
  // Initialize guard_
  for (string::iterator it(guard_.begin());
       it != guard_.end(); ++it)
  {
    *it = toupper(*it);
  }
  guard_.append("_HRL");
}

erl_header::~erl_header()
{
  if (os_.is_open())
  {
    write_footer();
  }
}

string
erl_header::basename()
{
  return name_.str() + ext;
}

const char*
erl_header::filename()
{
  return filename_.c_str();
}

string
erl_header::guard()
{
  return guard_;
}

void
erl_header::write_header()
{
  os_ << "-ifndef(" << guard_ << ")." << endl
      << "-define(" << guard_ << ", true)." << endl
      << endl;
}

void
erl_header::write_footer()
{
  os_ << endl
      << "-endif." << endl;
}


const char* erl_module::ext = ".erl";

erl_module::erl_module(UTL_ScopedName* name)
  : name_(name)
{
  // Initialize filename_
  be_global->get_src_dir(filename_);
  filename_.append(basename());
}

erl_module::~erl_module()
{
}

string
erl_module::basename()
{
  return name_.str() + ext;
}

const char*
erl_module::filename()
{
  return filename_.c_str();
}

void
erl_module::add_export(const string& fn)
{
  exports_.push_back(fn);
}

void
erl_module::add_include(const string& file)
{
  includes_.push_back(file);
}

void
erl_module::write_header()
{
  // Generate attributes
  os_ << "-module(" << name_ << ")." << endl;
 
  if (!exports_.empty())
  {
    os_ << "-export(" << to_list(exports_) << ")." << endl;
  }
  os_ << endl;

  // Generate includes
  if (!includes_.empty())
  {
    for (vector<string>::iterator it (includes_.begin());
         it != includes_.end(); ++it)
    {
      os_ << "-include(\"" << *it << "\")." << endl;
    }
    os_ << endl;
  }
}

ostream&
operator<<(ostream& os, const erl_module& rhs)
{
  return os << rhs.name_;
}


string
to_list(vector<string>& v)
{
  ostringstream os;

  os << "[";
  vector<string>::iterator it(v.begin());
  while (it != v.end())
  {
    os << *it++;
    if (it != v.end())
    {
      os << ", ";
    }
  }
  os << "]";

  return os.str();
}
